import React,{useContext, useState} from 'react'

export const Asp = () => {
   
    return (
     <div>
     
<p>Фильтры Razor Pages срабатывают до и после того, как страница Razor Page обработает запрос. В этом плане фильтры Razor Pages аналогичны фильтрам действий контроллеров в MVC.</p>
<p>Фильтры Razor Pages срабатывают</p>

<li><p>Когда уже выбран метод Razor Page для обработки запроса, но до привязки модели.</p></li>
<li><p>После завершения привязки данных, но до выполнения метода Razor Page, который обрабатывает запрос</p></li>
<li><p>После завершения методом обработки запроса.</p></li>

<p>Фильтры Razor Pages могут применяться как к отдельным страницам RazorPages, так и глобально ко всем страницам.</p>
<p>В плане функциональности фильтры представляют классы, которые реализуют либо интерфейс <span class="b">IPageFilter</span> (синхроннная версия), 
либо интерфейс <span class="b">IAsyncPageFilter</span> (асинхронная версия). 
Одновременно к стаице может применяться реализация только одного из этих интерфейсов. То есть можно применить либо синхронную, либо асинхронную версию, 
но не обе одновременно. Фреймворк ASP.NET Core вначале проверяет, применяются ли асинхронные фильтры - если они применяются, то именно они выполняются. 
Если асинхронные фильтры не применяются, то фреймворк ищет синхронные фильтры. Таким образом, если одновременно применяются и синхронные, и асинхронные 
фильтры, то выполяться будут только асинхронные фильтры.</p>
<p>Интерфейс <span class="b">IPageFilter</span> определяет следующие методы:</p>
<ul>
<li><p><span class="b">OnPageHandlerSelected</span>: вызывается, когда выбран метод Razor Page для обработки запроса, но до выполнения 
привязки модели.</p></li>
<li><p><span class="b">OnPageHandlerExecuting</span>: вызывается после завершения привязки данных, но до выполнения метода Razor Page, который обрабатывает запрос.</p></li>
<li><p><span class="b">OnPageHandlerExecuted</span>: вызывается после завершения работы метода, но до выполнения результата метода.</p></li>
</ul>
<p>Интерфейс <span class="b">IAsyncPageFilter</span> определяет следующие методы:</p>
<ul>
<li><p><span class="b">OnPageHandlerSelectionAsync</span>: выполняется асинхронно, когда выбран метод Razor Page для обработки запроса, но до выполнения 
привязки модели.</p></li>
<li><p><span class="b">OnPageHandlerExecutionAsync</span>: выполняется асинхронно после завершения привязки данных, но до выполнения метода Razor Page, который обрабатывает запрос.</p></li>
</ul>
<h3>Определение и применение синхронного фильтра</h3>
<p>Определим в проекте с RazorPages синхронный фильтр. Для реализации выберем примитивную задачу. Допустим, мы хотим запретить доступ пользователям 
с браузером Internet Explorer. Для этого определим следующий фильтр:</p>

<p>Функциональность синхронного фильтра определяется интерфейсом <span class="b">IPageFilter</span>. В данном случае мы не только реализуем данный интерфейс, 
но и наследуем класс System.Attribute. Наследовать класс в прицнипе необязательно. В данном случае это сделано для того, чтобы потом 
можно было применить фильтр в качестве атрибута к классам отдельных страниц RazorPages.</p>
<p>Поскольку нам надо проверять данные браузера до обработки запроса, то в данном случае мы можем использовать два метода: <code>OnPageHandlerExecuting</code> 
и <code>OnPageHandlerSelected</code>. В данном случае случае выбран метод <code>OnPageHandlerExecuting()</code>, который вызывается 
после привязки модели, но до обработки запроса страницей Razor Page. В качестве параметра он принимает объект <span class="b">PageHandlerExecutingContext</span>, 
которые позволяет нам инспектировать данные запроса. Его основные свойства:</p>
<ul>
<li><p><span class="b">HandlerArguments</span>: предоставляет информацию об аргументов, которые передаются в метод страницы RazorPage при обработке запроса.</p></li>
<li><p><span class="b">HandlerInstance</span>: возвращает экземпляр объекта, который содержит метод для обработки запроса. По сути содержит информацию о выбранной 
станице RazorPage</p></li>
<li><p><span class="b">HandlerMethod</span>: возвращает информацию о методе страницы Razor Page, который будет обрабатывать запрос</p></li>
<li><p><span class="b">HttpContext</span>: возвращает объект HttpContext, который содержит всю информацию о запросе и позволяет управлять ответом клиенту</p></li>
<li><p><span class="b">ModelState</span>: возвращает информацию о состоянии модели после выполнения привязки</p></li>
<li><p><span class="b">Result</span>: возвращает результат IActionResult, который представляет ответ клиенту</p></li>
<li><p><span class="b">RouteData</span>: возвращает данные маршрутов</p></li>
</ul>
<p>И в данном случае мы получаем через свойство HttpContext данные браузера клиента, с помощью регулярного выражения проверяем его, и если заголовок 
юзер-агента содержит соответствующие подстроки, то изменяем результат - теперь он представляет объект 
<code>BadRequestObjectResult</code>, с помощью которого пользователю отправляется статусный код 400 с некоторой информацией об ошибке.</p>
<p>Метод <code>OnPageHandlerSelected()</code> вызывается до выполнения привязки модели (соответственно до метода OnPageHandlerExecuting), но после выбора обработчика Razor Page, который должен будет обрабатывать запрос. В качестве параметра 
он принимает объект <span class="b">PageHandlerSelectedContext</span>, который инкапсулирует различную функциональность. Большая часть его свойств совпадает с 
выше рассмотренными свойствами PageHandlerExecutingContext.</p>
<p>Метод <code>OnPageHandlerExecuted()</code> вызывается после обработки станицей Razor Page запроса. В данном методе мы можем при необходимости выполнить некоторую 
постобработку. В качестве параметра он принимает объект <span class="b">PageHandlerExecutedContext</span>, свойства которого в основном совпадают с выше рассмотренными свойствами PageHandlerExecutingContext.</p>
<h3>Применение синхронного фильтра</h3>
<p>Вышеопределенный фильтр UserAgentPageFilter наследует класс Attribute, поэтому может применяться в качестве атрибута. Возьмем класс какой-нибудь страницы 
Razor Page, например, <span class="b">IndexModel</span>, класс страницы Index.cshtml, который имеется в проекте по умолчанию в файле Index.cshtml.cs:</p>
<p>Применим к нему фильтр:</p>

<p>На странице Index.cshtml предусмотрим какое-нибудь содержимое, которое будет выводиться при обработке запроса:</p>

<p>Обратимся к приложению из обычного браузера:</p>
<h3>Определение и использование асинхронного фильтра</h3>
<p>Создадим аналогичный асинхронный фильтр:</p>

 
<p>Асинхронный фильтр реализуется посредством применения интерфейса <span class="b">IAsyncPageFilter</span>. Также, чтобы можно было применить фильтр 
в качестве атрибута, в данном случае также наследуем класс Attribute.</p>
<p>Интерфейс IAsyncPageFilter определяет два метода. Сначала выполняется метод <span class="b">OnPageHandlerSelectionAsync()</span>, который вызывается 
после определения обработчика страницы Razor Page, который будет обрабатывать запрос, но до привязки модели. В качестве параметра он принимает выше уже упоминавшийся 
объект PageHandlerSelectedContext, с помощью свойств которого мы можем инспектировать данные запроса. Но в данном случае опять же ничего не делаем, 
а просто возвращаем завершенную задачу.</p>
<p>Метод <code>OnPageHandlerExecutionAsync()</code> вызывается после приязки модели, но до выполнения метода, и, таким образом, после вызова OnPageHandlerExecutionAsync. 
Он принимает два параметра. Первый параметр - объект PageHandlerExecutingContext уже выше рассматривался. С его помощью опять же можно получить всю многообразную информацию о запросе, 
какая страницы и какой ее метод выбран для обработки. А вот второй параметр - аргумент типа <span class="b">PageHandlerExecutionDelegate</span> 
очень важен. Фактически он предоставляет делегат, вызов которого позволяет передать обработку запроса далее - либо следующим фильтрам (если они имеются), 
либо непосредственно самой странице Razor Page. И в данном случае мы вызываем данный делегат:</p>
<pre class="brush:c#;">await next();</pre>
<p>Если же мы этого не сделаем, то запрос до страницы не дойдет, даже если у пользователя нормальный браузер, а не Internet Explorer.</p>
<p>Применение фильтра аналогично применению синхронной версии:</p>

<p>Соответственно мы получим те же самые результаты.</p>
<h3>Глобальная установка фильтра</h3>
<p>В примерах выше фильтр применялся только к отдельной странице Index.cshtml, но естественно мы можем задать его в качестве глобального и применять 
сразу ко всем страницам. Для этого изменим метод <span class="b">ConfigureServices()</span> в классе Startup:</p>

<p>Соответственно после этого нам не надо применять фильтр в качестве атрибута к отдельным страницам RazorPages.</p>

     </div>
     
    )
}